package huawei.odc100;

/**
 * 题目描述;山脉的个数(本题分值100)
 * 攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。
 * <p>
 * 地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。
 * <p>
 * 例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，
 * 代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和 8,9,10,11,12,13，
 * 最高峰高度分别为 4,3。最高峰位置分别为3,10。
 * <p>
 * 一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。
 * 登山者想要知道一张地图中有多少座山峰。
 * <p>
 * <p>
 * 输入描述 输入为一个整型数组，数组长度大于1。
 * 输出描述 输出地图中山峰的数量。
 * <p>
 * 用例1
 * 输入 0, 1, 2, 3, 2, 4
 * 输出 2
 * <p>
 * 解题思路
 * 如果当前元素是数组的第一个元素，并且大于下一个元素，或者是数组的最后一个元素，并且大于前一个元素，
 * 或者既不是第一个也不是最后一个元素，但大于前一个元素且大于后一个元素，则将计数器count加一。
 */
public class T2 {

    public static void main(String[] args) {

        int[] array = {0, 1, 2, 3, 2, 1, 0, 4, 3, 0};

        System.out.println(count_peaks(array));
    }

    public static int count_peaks(int[] hill_map) {
        int count = 0; // 初始化计数器为 0

        // 遍历数组 hill_map
        for (int i = 0; i < hill_map.length; i++) {

            // 如果当前位置在数组的开头，并且当前元素大于下一个元素
            if (i == 0 && hill_map[i] > hill_map[i + 1]) {
                count++; // 计数器加一
            }

            // 如果当前位置在数组的末尾，并且当前元素大于前一个元素
            if (i == hill_map.length - 1 && hill_map[i] > hill_map[i - 1]) {
                count++; // 计数器加一
            }

            // 如果当前位置不在开头和末尾，并且当前元素大于前一个元素且大于后一个元素
            if (i > 0 && i < hill_map.length - 1 && hill_map[i] > hill_map[i - 1] && hill_map[i] > hill_map[i + 1]) {
                count++; // 计数器加一
            }
        }
        return count; // 返回计数器的值作为结果
    }


}
